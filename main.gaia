// GaiaSpace Application in GaiaScript
// This represents the core domain model and application structure

// Application definition
application GaiaSpace {
  // Package declaration
  package: "com.gaiaspace"
  
  // Main application entry point
  @SpringBootApplication
  class GaiaSpaceApplication {}
  
  // Main function
  function main(args: String[]) {
    runApplication<GaiaSpaceApplication>(*args)
  }
}

// Configuration
// Web MVC Configuration
@Configuration
class WebMvcConfig : WebMvcConfigurer {
  @Override
  function addResourceHandlers(registry: ResourceHandlerRegistry) {
    registry.addResourceHandler("/static/**")
      .addResourceLocations("classpath:/static/")
  }
  
  @Override
  function addViewControllers(registry: ViewControllerRegistry) {
    registry.addViewController("/").setViewName("redirect:/dashboard")
  }
}

// GraphQL Configuration
@Configuration
class GraphQLConfig {
  @Bean
  function graphQLRuntimeWiring(): RuntimeWiring {
    return RuntimeWiring.newRuntimeWiring()
      .type("Query", builder -> {
        builder.dataFetcher("workspaces", env -> {
          // Fetch workspaces
        })
        builder.dataFetcher("users", env -> {
          // Fetch users
        })
      })
      .build()
  }
}

// Error Configuration
@ControllerAdvice
class ErrorConfig {
  private val logger = LoggerFactory.getLogger(ErrorConfig::class.java)
  
  @ExceptionHandler(Exception::class)
  function handleException(e: Exception): ResponseEntity<Map<String, String>> {
    logger.error("Unhandled exception", e)
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
      .body(mapOf("error" to "An unexpected error occurred"))
  }
  
  @ExceptionHandler(EntityNotFoundException::class)
  function handleEntityNotFound(e: EntityNotFoundException): ResponseEntity<Map<String, String>> {
    return ResponseEntity.status(HttpStatus.NOT_FOUND)
      .body(mapOf("error" to e.message ?: "Entity not found"))
  }
}

// Data Initializer for development
@Component
@Profile("dev")
class DataInitializer(
  private val userRepository: UserRepository,
  private val workspaceRepository: WorkspaceRepository,
  private val projectRepository: ProjectRepository,
  private val taskRepository: TaskRepository,
  private val passwordEncoder: PasswordEncoder
) : ApplicationRunner {
  
  @Override
  function run(args: ApplicationArguments) {
    if (userRepository.count() == 0L) {
      initializeData()
    }
  }
  
  private function initializeData() {
    // Create admin user
    val adminUser = User(
      username = "admin",
      email = "admin@example.com",
      displayName = "Admin User",
      password = passwordEncoder.encode("password"),
      roles = setOf(UserRole.ADMIN, UserRole.USER)
    )
    userRepository.save(adminUser)
    
    // Create sample workspace
    val workspace = Workspace(
      name = "Gaia Space",
      description = "Main workspace for Gaia Space project",
      createdBy = adminUser
    )
    workspaceRepository.save(workspace)
    
    // Create sample project
    val project = Project(
      name = "Backend Development",
      description = "Backend development for Gaia Space",
      workspace = workspace,
      createdBy = adminUser
    )
    projectRepository.save(project)
    
    // Create sample tasks
    val task1 = Task(
      title = "Set up database",
      description = "Initialize database schema and migrations",
      project = project,
      assignee = adminUser,
      createdBy = adminUser,
      status = TaskStatus.DONE
    )
    
    val task2 = Task(
      title = "Implement user auth",
      description = "Add JWT authentication and user management",
      project = project,
      assignee = adminUser,
      createdBy = adminUser,
      status = TaskStatus.IN_PROGRESS
    )
    
    taskRepository.saveAll(listOf(task1, task2))
  }
}

// Domain Models
// User model
@Entity
@Table(name = "users")
model User {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  @Column(unique = true)
  username: String
  
  @Column(unique = true)
  email: String
  
  displayName: String
  
  @JsonIgnore
  password: String
  
  avatarUrl: String?
  
  @ElementCollection(fetch = FetchType.EAGER)
  @Enumerated(EnumType.STRING)
  roles: Set<UserRole> = setOf(UserRole.USER)
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// User role enum
enum UserRole {
  USER, ADMIN, MANAGER
}

// Workspace model
@Entity
@Table(name = "workspaces")
model Workspace {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  name: String
  description: String
  avatarUrl: String?
  
  @ManyToOne
  createdBy: User
  
  @OneToMany(mappedBy = "workspace", cascade = [CascadeType.ALL])
  projects: MutableList<Project> = mutableListOf()
  
  @OneToMany(mappedBy = "workspace", cascade = [CascadeType.ALL])
  channels: MutableList<Channel> = mutableListOf()
  
  @OneToMany(mappedBy = "workspace", cascade = [CascadeType.ALL])
  members: MutableList<WorkspaceMember> = mutableListOf()
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Workspace member model
@Entity
@Table(name = "workspace_members")
model WorkspaceMember {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  @ManyToOne
  workspace: Workspace
  
  @ManyToOne
  user: User
  
  @Enumerated(EnumType.STRING)
  role: WorkspaceRole
  
  joinedAt: LocalDateTime = LocalDateTime.now()
}

// Workspace role enum
enum WorkspaceRole {
  OWNER, ADMIN, MEMBER, GUEST
}

// Project model
@Entity
@Table(name = "projects")
model Project {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  name: String
  description: String
  
  @Enumerated(EnumType.STRING)
  status: ProjectStatus = ProjectStatus.PLANNING
  
  dueDate: LocalDate?
  icon: String?
  
  @ManyToOne
  workspace: Workspace
  
  @ManyToOne
  createdBy: User
  
  @OneToMany(mappedBy = "project", cascade = [CascadeType.ALL])
  tasks: MutableList<Task> = mutableListOf()
  
  @OneToMany(mappedBy = "project", cascade = [CascadeType.ALL])
  boards: MutableList<Board> = mutableListOf()
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Project status enum
enum ProjectStatus {
  PLANNING, ACTIVE, ON_HOLD, COMPLETED, CANCELED
}

// Task model
@Entity
@Table(name = "tasks")
model Task {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  title: String
  description: String
  
  @Enumerated(EnumType.STRING)
  status: TaskStatus = TaskStatus.TODO
  
  @Enumerated(EnumType.STRING)
  priority: TaskPriority = TaskPriority.MEDIUM
  
  dueDate: LocalDate?
  estimatedHours: Float?
  spentHours: Float?
  
  @ManyToOne
  project: Project
  
  @ManyToOne
  assignee: User?
  
  @ManyToOne
  createdBy: User
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Task status enum
enum TaskStatus {
  TODO, IN_PROGRESS, REVIEW, DONE, CANCELED
}

// Task priority enum
enum TaskPriority {
  LOW, MEDIUM, HIGH, CRITICAL
}

// Board model
@Entity
@Table(name = "boards")
model Board {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  name: String
  description: String
  
  @ManyToOne
  project: Project
  
  @ManyToOne
  createdBy: User
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Channel model
@Entity
@Table(name = "channels")
model Channel {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  name: String
  description: String
  
  @Enumerated(EnumType.STRING)
  type: ChannelType
  
  @ManyToOne
  workspace: Workspace
  
  @ManyToOne
  createdBy: User
  
  @OneToMany(mappedBy = "channel", cascade = [CascadeType.ALL])
  messages: MutableList<Message> = mutableListOf()
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Channel type enum
enum ChannelType {
  TEXT, VOICE, DOCUMENT, TASK, CALENDAR
}

// Message model
@Entity
@Table(name = "messages")
model Message {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  content: String
  
  @ManyToOne
  channel: Channel
  
  @ManyToOne
  sender: User
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Document model
@Entity
@Table(name = "documents")
model Document {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  title: String
  content: String
  
  @ManyToOne
  project: Project
  
  @ManyToOne
  parentDocument: Document?
  
  @OneToMany(mappedBy = "parentDocument", cascade = [CascadeType.ALL])
  childDocuments: MutableList<Document> = mutableListOf()
  
  @ManyToOne
  createdBy: User
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Git Repository model
@Entity
@Table(name = "git_repositories")
model GitRepository {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  name: String
  url: String
  branch: String = "main"
  
  @ManyToOne
  project: Project
  
  @ManyToOne
  createdBy: User
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Discord Integration model
@Entity
@Table(name = "discord_integrations")
model DiscordIntegration {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  guildId: String
  accessToken: String
  refreshToken: String
  tokenExpiry: LocalDateTime
  active: Boolean = true
  
  @ManyToOne
  workspace: Workspace
  
  @ManyToOne
  createdBy: User
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Pipeline model
@Entity
@Table(name = "pipelines")
model Pipeline {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  name: String
  description: String
  
  @Column(columnDefinition = "TEXT")
  config: String
  
  @ManyToOne
  project: Project
  
  @ManyToOne
  createdBy: User
  
  @OneToMany(mappedBy = "pipeline", cascade = [CascadeType.ALL])
  runs: MutableList<PipelineRun> = mutableListOf()
  
  @CreationTimestamp
  createdAt: LocalDateTime
  
  @UpdateTimestamp
  updatedAt: LocalDateTime
}

// Pipeline Run model
@Entity
@Table(name = "pipeline_runs")
model PipelineRun {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  id: Long
  
  @Enumerated(EnumType.STRING)
  status: PipelineStatus = PipelineStatus.PENDING
  
  startTime: LocalDateTime?
  endTime: LocalDateTime?
  
  @Column(columnDefinition = "TEXT")
  logs: String = ""
  
  @ManyToOne
  pipeline: Pipeline
  
  @ManyToOne
  triggeredBy: User
  
  @CreationTimestamp
  createdAt: LocalDateTime
}

// Pipeline Status enum
enum PipelineStatus {
  PENDING, RUNNING, SUCCEEDED, FAILED, CANCELED
}

// Repositories
// User Repository
@Repository
interface UserRepository {
  extends: "JpaRepository<User, Long>"
  
  function findByUsername(username: String): User?
  function findByEmail(email: String): User?
  function existsByUsername(username: String): Boolean
  function existsByEmail(email: String): Boolean
}

// Workspace Repository
@Repository
interface WorkspaceRepository {
  extends: "JpaRepository<Workspace, Long>"
  
  function findByCreatedById(userId: Long): List<Workspace>
  function findByMembersUserId(userId: Long): List<Workspace>
}

// Workspace Member Repository
@Repository
interface WorkspaceMemberRepository {
  extends: "JpaRepository<WorkspaceMember, Long>"
  
  function findByWorkspaceIdAndUserId(workspaceId: Long, userId: Long): WorkspaceMember?
  function existsByWorkspaceIdAndUserId(workspaceId: Long, userId: Long): Boolean
  function findByUserId(userId: Long): List<WorkspaceMember>
}

// Project Repository
@Repository
interface ProjectRepository {
  extends: "JpaRepository<Project, Long>"
  
  function findByWorkspaceId(workspaceId: Long): List<Project>
  function findByCreatedById(userId: Long): List<Project>
}

// Task Repository
@Repository
interface TaskRepository {
  extends: "JpaRepository<Task, Long>"
  
  function findByProjectId(projectId: Long): List<Task>
  function findByAssigneeId(userId: Long): List<Task>
  function findByStatus(status: TaskStatus): List<Task>
  function countByProjectIdAndStatus(projectId: Long, status: TaskStatus): Long
}

// Board Repository
@Repository
interface BoardRepository {
  extends: "JpaRepository<Board, Long>"
  
  function findByProjectId(projectId: Long): List<Board>
}

// Channel Repository
@Repository
interface ChannelRepository {
  extends: "JpaRepository<Channel, Long>"
  
  function findByWorkspaceId(workspaceId: Long): List<Channel>
  function findByType(type: ChannelType): List<Channel>
}

// Message Repository
@Repository
interface MessageRepository {
  extends: "JpaRepository<Message, Long>"
  
  function findByChannelId(channelId: Long): List<Message>
  function findByChannelIdOrderByCreatedAtDesc(channelId: Long, pageable: Pageable): Page<Message>
}

// Document Repository
@Repository
interface DocumentRepository {
  extends: "JpaRepository<Document, Long>"
  
  function findByProjectId(projectId: Long): List<Document>
  function findByParentDocumentId(parentDocumentId: Long): List<Document>
}

// Git Repository Repository
@Repository
interface GitRepositoryRepository {
  extends: "JpaRepository<GitRepository, Long>"
  
  function findByProjectId(projectId: Long): List<GitRepository>
}

// Discord Integration Repository
@Repository
interface DiscordIntegrationRepository {
  extends: "JpaRepository<DiscordIntegration, Long>"
  
  function findByWorkspaceId(workspaceId: Long): DiscordIntegration?
  function findByGuildId(guildId: String): DiscordIntegration?
}

// Pipeline Repository
@Repository
interface PipelineRepository {
  extends: "JpaRepository<Pipeline, Long>"
  
  function findByProjectId(projectId: Long): List<Pipeline>
}

// Pipeline Run Repository
@Repository
interface PipelineRunRepository {
  extends: "JpaRepository<PipelineRun, Long>"
  
  function findByPipelineId(pipelineId: Long): List<PipelineRun>
  function findByPipelineIdOrderByCreatedAtDesc(pipelineId: Long): List<PipelineRun>
}

// Security Configuration
@Configuration
@EnableWebSecurity
class SecurityConfig {
  @Autowired
  private userDetailsService: UserDetailsService
  
  @Autowired
  private jwtAuthenticationFilter: JwtAuthenticationFilter
  
  @Bean
  function securityFilterChain(http: HttpSecurity): SecurityFilterChain {
    http
      .csrf().disable()
      .authorizeHttpRequests(authorize -> 
        authorize
          .requestMatchers("/api/auth/**", "/h2-console/**", "/", "/index.html", "/static/**").permitAll()
          .anyRequest().authenticated()
      )
      .sessionManagement()
        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
      .and()
      .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter::class.java)
    
    return http.build()
  }
  
  @Bean
  function passwordEncoder(): PasswordEncoder {
    return BCryptPasswordEncoder()
  }
}

// JWT Authentication Filter
@Component
class JwtAuthenticationFilter(private val jwtTokenProvider: JwtTokenProvider) : OncePerRequestFilter() {
  @Override
  function doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain) {
    try {
      val jwt = getJwtFromRequest(request)
      
      if (jwt != null && jwtTokenProvider.validateToken(jwt)) {
        val authentication = jwtTokenProvider.getAuthentication(jwt)
        SecurityContextHolder.getContext().authentication = authentication
      }
    } catch (ex: Exception) {
      // Log exception, don't set auth
    }
    
    filterChain.doFilter(request, response)
  }
  
  private function getJwtFromRequest(request: HttpServletRequest): String? {
    val bearerToken = request.getHeader("Authorization")
    
    if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
      return bearerToken.substring(7)
    }
    
    return null
  }
}

// JWT Token Provider
@Component
class JwtTokenProvider {
  @Value("\${app.jwtSecret}")
  private secretKey: String
  
  @Value("\${app.jwtExpirationInMs}")
  private expirationInMs: Long
  
  private var initialized = false
  private var keyBytes: ByteArray? = null
  
  @PostConstruct
  function init() {
    keyBytes = secretKey.toByteArray()
    initialized = true
  }
  
  function generateToken(user: User): String {
    val now = Date()
    val expiryDate = Date(now.time + expirationInMs)
    
    val claims = Jwts.claims().setSubject(user.id.toString())
    claims.put("username", user.username)
    claims.put("roles", user.roles.map { it.name })
    
    return Jwts.builder()
      .setClaims(claims)
      .setIssuedAt(now)
      .setExpiration(expiryDate)
      .signWith(Keys.hmacShaKeyFor(keyBytes))
      .compact()
  }
  
  function getUserIdFromToken(token: String): Long? {
    val claims = Jwts.parserBuilder()
      .setSigningKey(Keys.hmacShaKeyFor(keyBytes))
      .build()
      .parseClaimsJws(token)
      .body
    
    return claims.subject.toLongOrNull()
  }
  
  function validateToken(token: String): Boolean {
    try {
      Jwts.parserBuilder()
        .setSigningKey(Keys.hmacShaKeyFor(keyBytes))
        .build()
        .parseClaimsJws(token)
      return true
    } catch (ex: Exception) {
      // Invalid token
      return false
    }
  }
  
  function getAuthentication(token: String): Authentication {
    val claims = Jwts.parserBuilder()
      .setSigningKey(Keys.hmacShaKeyFor(keyBytes))
      .build()
      .parseClaimsJws(token)
      .body
    
    val authorities = (claims["roles"] as List<String>).map { SimpleGrantedAuthority("ROLE_$it") }
    
    val principal = User(
      claims.subject, 
      claims["username"] as String, 
      "", 
      true, 
      true, 
      true, 
      true, 
      authorities
    )
    
    return UsernamePasswordAuthenticationToken(principal, "", authorities)
  }
}

// Services
// User Service
@Service
class UserService {
  @Autowired
  private userRepository: UserRepository
  
  @Autowired
  private passwordEncoder: PasswordEncoder
  
  @Autowired
  private jwtTokenProvider: JwtTokenProvider
  
  function createUser(username: String, email: String, password: String, displayName: String): User {
    if (userRepository.existsByUsername(username)) {
      throw new IllegalArgumentException("Username already exists")
    }
    
    if (userRepository.existsByEmail(email)) {
      throw new IllegalArgumentException("Email already exists")
    }
    
    val user = new User(
      username = username,
      email = email,
      displayName = displayName,
      password = passwordEncoder.encode(password)
    )
    
    return userRepository.save(user)
  }
  
  function authenticateUser(username: String, password: String): String {
    val user = userRepository.findByUsername(username)
      ?: throw new UsernameNotFoundException("User not found")
      
    if (!passwordEncoder.matches(password, user.password)) {
      throw new BadCredentialsException("Invalid password")
    }
    
    return jwtTokenProvider.generateToken(user)
  }
  
  function getUserById(id: Long): User {
    return userRepository.findById(id)
      .orElseThrow { new EntityNotFoundException("User not found") }
  }
  
  function updateUser(id: Long, displayName: String?, avatarUrl: String?): User {
    val user = getUserById(id)
    
    if (displayName != null) {
      user.displayName = displayName
    }
    
    if (avatarUrl != null) {
      user.avatarUrl = avatarUrl
    }
    
    return userRepository.save(user)
  }
  
  function getAllUsers(): List<User> {
    return userRepository.findAll()
  }
  
  function changePassword(id: Long, currentPassword: String, newPassword: String): User {
    val user = getUserById(id)
    
    if (!passwordEncoder.matches(currentPassword, user.password)) {
      throw new BadCredentialsException("Current password is incorrect")
    }
    
    user.password = passwordEncoder.encode(newPassword)
    return userRepository.save(user)
  }
}

// Task Service
@Service
class TaskService {
  @Autowired
  private taskRepository: TaskRepository
  
  @Autowired
  private projectRepository: ProjectRepository
  
  @Autowired
  private userRepository: UserRepository
  
  function createTask(title: String, description: String, projectId: Long, 
                     priority: TaskPriority, assigneeId: Long?, createdById: Long): Task {
    val project = projectRepository.findById(projectId)
      .orElseThrow { new EntityNotFoundException("Project not found") }
      
    val createdBy = userRepository.findById(createdById)
      .orElseThrow { new EntityNotFoundException("User not found") }
      
    val assignee = if (assigneeId != null) {
      userRepository.findById(assigneeId)
        .orElseThrow { new EntityNotFoundException("Assignee not found") }
    } else {
      null
    }
    
    val task = new Task(
      title = title,
      description = description,
      priority = priority,
      project = project,
      assignee = assignee,
      createdBy = createdBy
    )
    
    return taskRepository.save(task)
  }
  
  function updateTaskStatus(taskId: Long, status: TaskStatus): Task {
    val task = taskRepository.findById(taskId)
      .orElseThrow { new EntityNotFoundException("Task not found") }
      
    task.status = status
    return taskRepository.save(task)
  }
  
  function getTasksByProject(projectId: Long): List<Task> {
    return taskRepository.findByProjectId(projectId)
  }
  
  function getTasksByAssignee(userId: Long): List<Task> {
    return taskRepository.findByAssigneeId(userId)
  }
  
  function updateTask(taskId: Long, title: String?, description: String?, 
                    priority: TaskPriority?, assigneeId: Long?): Task {
    val task = taskRepository.findById(taskId)
      .orElseThrow { new EntityNotFoundException("Task not found") }
    
    if (title != null) {
      task.title = title
    }
    
    if (description != null) {
      task.description = description
    }
    
    if (priority != null) {
      task.priority = priority
    }
    
    if (assigneeId != null) {
      val assignee = userRepository.findById(assigneeId)
        .orElseThrow { new EntityNotFoundException("Assignee not found") }
      task.assignee = assignee
    }
    
    return taskRepository.save(task)
  }
  
  function deleteTask(taskId: Long) {
    if (!taskRepository.existsById(taskId)) {
      throw new EntityNotFoundException("Task not found")
    }
    taskRepository.deleteById(taskId)
  }
}

// Workspace Service
@Service
class WorkspaceService {
  @Autowired
  private workspaceRepository: WorkspaceRepository
  
  @Autowired
  private userRepository: UserRepository
  
  @Autowired
  private workspaceMemberRepository: WorkspaceMemberRepository
  
  function createWorkspace(name: String, description: String, createdById: Long): Workspace {
    val creator = userRepository.findById(createdById)
      .orElseThrow { new EntityNotFoundException("User not found") }
      
    val workspace = new Workspace(
      name = name,
      description = description,
      createdBy = creator
    )
    
    val savedWorkspace = workspaceRepository.save(workspace)
    
    // Add creator as owner
    val member = new WorkspaceMember(
      workspace = savedWorkspace,
      user = creator,
      role = WorkspaceRole.OWNER
    )
    workspaceMemberRepository.save(member)
    
    return savedWorkspace
  }
  
  function getWorkspaceById(id: Long): Workspace {
    return workspaceRepository.findById(id)
      .orElseThrow { new EntityNotFoundException("Workspace not found") }
  }
  
  function getUserWorkspaces(userId: Long): List<Workspace> {
    return workspaceRepository.findByMembersUserId(userId)
  }
  
  function addWorkspaceMember(workspaceId: Long, userId: Long, role: WorkspaceRole): WorkspaceMember {
    val workspace = getWorkspaceById(workspaceId)
    val user = userRepository.findById(userId)
      .orElseThrow { new EntityNotFoundException("User not found") }
      
    // Check if already a member
    workspaceMemberRepository.findByWorkspaceIdAndUserId(workspaceId, userId)?.let {
      throw new IllegalArgumentException("User is already a member of this workspace")
    }
    
    val member = new WorkspaceMember(
      workspace = workspace,
      user = user,
      role = role
    )
    
    return workspaceMemberRepository.save(member)
  }
}

// Discord Service
@Service
class DiscordService {
  @Autowired
  private discordIntegrationRepository: DiscordIntegrationRepository
  
  @Autowired
  private workspaceRepository: WorkspaceRepository
  
  @Autowired
  private userRepository: UserRepository
  
  @Value("\${discord.clientId}")
  private clientId: String
  
  @Value("\${discord.clientSecret}")
  private clientSecret: String
  
  @Value("\${discord.redirectUri}")
  private redirectUri: String
  
  function createIntegration(code: String, workspaceId: Long, userId: Long): DiscordIntegration {
    val workspace = workspaceRepository.findById(workspaceId)
      .orElseThrow { new EntityNotFoundException("Workspace not found") }
      
    val user = userRepository.findById(userId)
      .orElseThrow { new EntityNotFoundException("User not found") }
    
    // Process OAuth token exchange
    // Store discord integration details
    
    val integration = new DiscordIntegration(
      guildId = "123456789012345678",
      accessToken = "access_token",
      refreshToken = "refresh_token",
      tokenExpiry = LocalDateTime.now().plusDays(7),
      workspace = workspace,
      createdBy = user
    )
    
    return discordIntegrationRepository.save(integration)
  }
  
  function sendMessageToDiscord(workspaceId: Long, channelId: String, message: String): Boolean {
    val integration = discordIntegrationRepository.findByWorkspaceId(workspaceId)
      ?: throw new EntityNotFoundException("Discord integration not found")
      
    // Send message to Discord API
    
    return true
  }
  
  function deactivateIntegration(workspaceId: Long): DiscordIntegration {
    val integration = discordIntegrationRepository.findByWorkspaceId(workspaceId)
      ?: throw new EntityNotFoundException("Discord integration not found")
      
    integration.active = false
    return discordIntegrationRepository.save(integration)
  }
}

// Pipeline Service
@Service
class PipelineService {
  @Autowired
  private pipelineRepository: PipelineRepository
  
  @Autowired
  private pipelineRunRepository: PipelineRunRepository
  
  @Autowired
  private projectRepository: ProjectRepository
  
  @Autowired
  private userRepository: UserRepository
  
  function createPipeline(name: String, description: String, config: String, 
                        projectId: Long, createdById: Long): Pipeline {
    val project = projectRepository.findById(projectId)
      .orElseThrow { new EntityNotFoundException("Project not found") }
      
    val createdBy = userRepository.findById(createdById)
      .orElseThrow { new EntityNotFoundException("User not found") }
      
    val pipeline = new Pipeline(
      name = name,
      description = description,
      config = config,
      project = project,
      createdBy = createdBy
    )
    
    return pipelineRepository.save(pipeline)
  }
  
  function runPipeline(pipelineId: Long, triggeredById: Long): PipelineRun {
    val pipeline = pipelineRepository.findById(pipelineId)
      .orElseThrow { new EntityNotFoundException("Pipeline not found") }
      
    val user = userRepository.findById(triggeredById)
      .orElseThrow { new EntityNotFoundException("User not found") }
      
    val run = new PipelineRun(
      pipeline = pipeline,
      triggeredBy = user,
      status = PipelineStatus.RUNNING,
      startTime = LocalDateTime.now()
    )
    
    // Execute pipeline in background
    
    return pipelineRunRepository.save(run)
  }
}

// GaiaScript Controller
@RestController
@RequestMapping("/api/gaiascript")
class GaiaScriptController {
  @Autowired
  private kotlinCompilerService: KotlinCompilerService
  
  @PostMapping("/compile")
  function compileGaiaScript(@RequestBody request: CompileRequest): ResponseEntity<CompileResponse> {
    try {
      // Generate Kotlin code from GaiaScript
      val kotlinCode = kotlinCompilerService.generateKotlinFromGaiaScript(
        request.gaiaScript, 
        request.appName
      )
      
      // Compile the generated Kotlin code
      val compilationResult = kotlinCompilerService.compileKotlinCode(
        kotlinCode, 
        "com.gaiaspace.generated.${request.appName.lowercase()}"
      )
      
      return ResponseEntity.ok(
        CompileResponse(
          success = compilationResult.success,
          message = compilationResult.message,
          kotlinCode = kotlinCode,
          compiledClasses = compilationResult.compiledClasses,
          outputPath = compilationResult.outputDirectory
        )
      )
    } catch (e: Exception) {
      return ResponseEntity.ok(
        CompileResponse(
          success = false,
          message = "Error processing GaiaScript: ${e.message}"
        )
      )
    }
  }
  
  @GetMapping("/sample")
  function getSampleGaiaScript(): ResponseEntity<Map<String, String>> {
    val sampleGaiaScript = """
      component App {
        // UI Components
        γ.Panel(width: 300, height: 500) {
          γ.Label(text: "Hello from GaiaScript!")
          γ.Button(text: "Click me", onClick: handleClick)
        }
        
        // Event handler
        function handleClick() {
          console.log("Button clicked")
        }
      }
      
      // Initialize app
      App.render()
    """.trimIndent()
    
    return ResponseEntity.ok(mapOf(
      "gaiaScript" to sampleGaiaScript,
      "appName" to "SampleApp"
    ))
  }
  
  @GetMapping("/cleanup")
  function cleanupCompilationFiles(): ResponseEntity<Map<String, String>> {
    kotlinCompilerService.cleanup()
    return ResponseEntity.ok(mapOf("message" to "Cleaned up compilation files"))
  }
}

// KotlinCompiler Service
@Service
class KotlinCompilerService {
  private val logger = LoggerFactory.getLogger(KotlinCompilerService::class.java)
  
  private val tempDir = Paths.get(System.getProperty("java.io.tmpdir"), "gaia_kotlin_compiler")
  
  function compileKotlinCode(kotlinCode: String, packageName: String = "com.gaiaspace.generated"): CompilationResult {
    logger.info("Compiling Kotlin code with package: $packageName")
    
    // Create temp directory for compilation
    val tempDirFile = tempDir.toFile()
    if (tempDirFile.exists()) {
      FileSystemUtils.deleteRecursively(tempDirFile)
    }
    Files.createDirectories(tempDir)
    
    // Create package directories
    val packagePath = packageName.replace(".", "/")
    val srcDir = tempDir.resolve("src/main/kotlin/$packagePath")
    Files.createDirectories(srcDir)
    
    // Write Kotlin source file
    val sourceFile = srcDir.resolve("GeneratedApp.kt").toFile()
    
    val fullSource = """
      package $packageName
      
      $kotlinCode
    """.trimIndent()
    
    sourceFile.writeText(fullSource)
    
    // Create build.gradle.kts file
    val buildGradleFile = tempDir.resolve("build.gradle.kts").toFile()
    buildGradleFile.writeText("""
      plugins {
        id("org.jetbrains.kotlin.jvm") version "1.9.22"
        application
      }
      
      repositories {
        mavenCentral()
        google()
      }
      
      dependencies {
        implementation("org.jetbrains.kotlin:kotlin-stdlib")
        implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
        // For Android/UI dependencies (just stubs for compilation)
        compileOnly("androidx.activity:activity-compose:1.8.1")
        compileOnly("androidx.compose.material3:material3:1.1.2")
        compileOnly("androidx.compose.foundation:foundation:1.5.4")
        compileOnly("androidx.compose.ui:ui:1.5.4")
        compileOnly("org.tensorflow:tensorflow-lite:2.14.0")
      }
      
      kotlin {
        jvmToolchain(17)
      }
      
      application {
        mainClass.set("$packageName.GeneratedAppKt")
      }
    """.trimIndent())
    
    // Create settings.gradle.kts
    val settingsGradleFile = tempDir.resolve("settings.gradle.kts").toFile()
    settingsGradleFile.writeText("""
      rootProject.name = "gaia-generated-app"
    """.trimIndent())
    
    // Execute gradle to compile
    try {
      val process = ProcessBuilder(
        "./gradlew", "compileKotlin", "--no-daemon", "--console=plain"
      )
        .directory(tempDirFile)
        .redirectErrorStream(true)
        .start()
      
      val output = process.inputStream.bufferedReader().readText()
      val completed = process.waitFor(60, TimeUnit.SECONDS)
      
      if (!completed) {
        process.destroyForcibly()
        return CompilationResult(
          success = false,
          message = "Compilation timed out after 60 seconds."
        )
      }
      
      if (process.exitValue() != 0) {
        return CompilationResult(
          success = false,
          message = "Compilation failed:\n$output"
        )
      }
      
      // Find compiled class files
      val classesDir = tempDir.resolve("build/classes/kotlin/main")
      val classFiles = Files.walk(classesDir)
        .filter { it.toString().endsWith(".class") }
        .map { classesDir.relativize(it).toString() }
        .toList()
      
      return CompilationResult(
        success = true,
        message = "Compilation successful. Generated ${classFiles.size} class files.",
        compiledClasses = classFiles,
        outputDirectory = classesDir.toString()
      )
      
    } catch (e: Exception) {
      logger.error("Error compiling Kotlin code", e)
      return CompilationResult(
        success = false,
        message = "Error: ${e.message}"
      )
    }
  }
  
  function generateKotlinFromGaiaScript(gaiaScript: String, appName: String): String {
    // For now, just a simple templating system
    return """
      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.foundation.layout.*
      import androidx.compose.material3.*
      import androidx.compose.runtime.*
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.Alignment
      
      /**
       * Generated from GaiaScript:
       * ```
       * ${gaiaScript.lines().joinToString("\n * ")}
       * ```
       */
      class ${appName}Activity : ComponentActivity() {
        override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          setContent {
            MaterialTheme {
              Surface(
                modifier = Modifier.fillMaxSize(),
                color = MaterialTheme.colorScheme.background
              ) {
                ${appName}Content()
              }
            }
          }
        }
      }
      
      @Composable
      fun ${appName}Content() {
        var counter by remember { mutableStateOf(0) }
        
        Column(
          modifier = Modifier.fillMaxSize(),
          verticalArrangement = Arrangement.Center,
          horizontalAlignment = Alignment.CenterHorizontally
        ) {
          Text("Welcome to $appName")
          Text("Counter: ${"$"}{counter}")
          Button(onClick = { counter++ }) {
            Text("Increment")
          }
        }
      }
    """.trimIndent()
  }
  
  function cleanup() {
    try {
      FileSystemUtils.deleteRecursively(tempDir)
    } catch (e: Exception) {
      logger.warn("Failed to clean up temp directory: $tempDir", e)
    }
  }
}